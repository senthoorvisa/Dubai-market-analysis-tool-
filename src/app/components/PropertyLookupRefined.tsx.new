"use client";

import { useState, useEffect, useRef } from 'react';
import Link from 'next/link';
import axios from 'axios';
import { 
  FaArrowLeft, FaSearch, FaSpinner, FaHome, FaBed, FaBath, 
  FaRulerCombined, FaBuilding, FaCalendarAlt, FaChartLine,
  FaMapMarkerAlt, FaTag, FaExternalLinkAlt, FaChevronRight, FaChevronLeft,
  FaFilter
} from 'react-icons/fa';
import { 
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, 
  Legend, ResponsiveContainer, ReferenceLine, BarChart, Bar
} from 'recharts';
import { getPropertyInfo } from '../services/openAiService';
import apiKeyService from '../services/apiKeyService';

// API response structure
interface PricePoint {
  year: number;
  price: number;
}

interface PropertyMetadata {
  id: string;
  name: string;
  beds: number;
  baths: number;
  sqft: number;
  developer: string;
  purchaseYear: number;
  location: string;
  status: 'Completed' | 'Under Construction' | 'Planned';
  coordinates: {
    lat: number;
    lng: number;
  };
}

interface NearbyProperty {
  id: string;
  name: string;
  distance: number; // in km
  originalPrice: number;
  originalYear: number;
  currentPrice: number;
  currentYear: number;
  beds: number;
  baths: number;
  sqft: number;
  developer: string;
}

interface OngoingProject {
  id: string;
  name: string;
  status: 'In Ideation' | 'Pre-Funding' | 'Under Construction' | 'Nearly Complete';
  expectedCompletion: string; // Year or date
  developer: string;
}

interface DeveloperInfo {
  id: string;
  name: string;
  headquarters: string;
  totalProjects: number;
  averageROI: number;
  revenueByYear: Array<{
    year: number;
    residential: number;
    commercial: number;
    mixedUse: number;
  }>;
}

interface PropertyData {
  metadata: PropertyMetadata;
  priceHistory: PricePoint[];
  nearby: NearbyProperty[];
  ongoingProjects: OngoingProject[];
  developer: DeveloperInfo;
}

// Define property search criteria
interface PropertySearchCriteria {
  location?: string;
  propertyType?: string;
  bedrooms?: number;
  priceRange?: string;
  amenities?: string[];
}

// Helper functions for generating data
function generatePriceHistory(purchaseYear: number): PricePoint[] {
  const priceHistory: PricePoint[] = [];
  const basePrice = 500000 + (Math.random() * 1500000);
  const currentYear = new Date().getFullYear();
  
  for (let year = purchaseYear; year <= currentYear; year++) {
    // Calculate price growth with some randomness
    const growthRate = 0.05 + (Math.random() * 0.1); // 5-15% growth per year
    const yearsSincePurchase = year - purchaseYear;
    const price = basePrice * Math.pow(1 + growthRate, yearsSincePurchase);
    
    priceHistory.push({
      year,
      price: Math.round(price / 1000) * 1000 // Round to nearest thousand
    });
  }
  
  return priceHistory;
}

function generateNearbyProperties(location: string, bedrooms: number): NearbyProperty[] {
  const nearby: NearbyProperty[] = [];
  const nearbyCount = Math.floor(Math.random() * 3) + 3; // 3-5 nearby properties
  const currentYear = new Date().getFullYear();
  const basePrice = 500000 + (Math.random() * 1500000);
  
  const developers = [
    'Emaar Properties', 'Damac Properties', 'Nakheel', 'Dubai Properties',
    'Meraas', 'Sobha Realty', 'Azizi Developments', 'Danube Properties'
  ];
  
  for (let i = 0; i < nearbyCount; i++) {
    const distance = (Math.random() * 2 + 0.5).toFixed(1); // 0.5-2.5 km
    const originalYear = 2015 - Math.floor(Math.random() * 5); // 0-5 years before 2015
    const originalPrice = basePrice * (0.7 + Math.random() * 0.6); // 70-130% of base price
    const currentPrice = originalPrice * (1.4 + Math.random() * 0.6); // 140-200% growth
    const nearbyBedrooms = Math.max(1, bedrooms + (Math.floor(Math.random() * 3) - 1)); // -1 to +1 bedrooms
    
    nearby.push({
      id: `nearby-${i}-${Date.now().toString().slice(-4)}`,
      name: `${location} ${nearbyBedrooms === 0 ? 'Studio' : `${nearbyBedrooms} BR`} ${['Apartment', 'Villa', 'Penthouse', 'Townhouse'][Math.floor(Math.random() * 4)]}`,
      distance: parseFloat(distance),
      originalPrice: Math.round(originalPrice / 1000) * 1000,
      originalYear,
      currentPrice: Math.round(currentPrice / 1000) * 1000,
      currentYear,
      beds: nearbyBedrooms,
      baths: nearbyBedrooms + (Math.random() > 0.7 ? 1 : 0),
      sqft: Math.round((800 + (nearbyBedrooms * 400) + Math.random() * 300) / 10) * 10,
      developer: developers[Math.floor(Math.random() * developers.length)]
    });
  }
  
  return nearby;
}

function generateOngoingProjects(location: string, developer: string): OngoingProject[] {
  const ongoingProjects: OngoingProject[] = [];
  const projectCount = 3;
  
  const projectStatuses = ['In Ideation', 'Pre-Funding', 'Under Construction', 'Nearly Complete'];
  
  for (let i = 0; i < projectCount; i++) {
    const status = projectStatuses[Math.floor(Math.random() * projectStatuses.length)] as any;
    const completionYear = new Date().getFullYear() + Math.floor(Math.random() * 4) + 1;
    
    ongoingProjects.push({
      id: `project-${i}-${Date.now().toString().slice(-4)}`,
      name: `${['The', 'New', 'Royal', 'Grand', 'Elite'][i % 5]} ${location} ${['Residences', 'Towers', 'Heights', 'Estate', 'Gardens'][i % 5]}`,
      status,
      expectedCompletion: completionYear.toString(),
      developer
    });
  }
  
  return ongoingProjects;
}

function generateDeveloperInfo(developer: string): DeveloperInfo {
  const currentYear = new Date().getFullYear();
  
  return {
    id: `dev-${developer.toLowerCase().replace(/\\s+/g, '-')}-${Date.now().toString().slice(-4)}`,
    name: developer,
    headquarters: 'Dubai, UAE',
    totalProjects: Math.floor(Math.random() * 30) + 20,
    averageROI: Math.round((Math.random() * 6) + 4 + Math.random()),
    revenueByYear: Array.from({ length: 6 }, (_, i) => ({
      year: currentYear - 5 + i,
      residential: Math.round(Math.random() * 5000) + 2000,
      commercial: Math.round(Math.random() * 3000) + 1000,
      mixedUse: Math.round(Math.random() * 2000) + 500
    }))
  };
}

// Dubai locations for dropdown
const dubaiLocations = [
  'Dubai Marina',
  'Downtown Dubai',
  'Palm Jumeirah',
  'Jumeirah Beach Residence',
  'Business Bay',
  'Dubai Hills Estate',
  'Jumeirah Lake Towers',
  'Arabian Ranches',
  'Mirdif',
  'Damac Hills',
  'Dubai Silicon Oasis',
  'International City',
  'Dubai Sports City',
  'Emirates Hills',
  'Jumeirah Village Circle'
];

// Property types for dropdown
const propertyTypes = [
  'Apartment',
  'Villa',
  'Townhouse',
  'Penthouse',
  'Duplex',
  'Studio',
  'Office',
  'Commercial Space',
  'Retail Shop',
  'Plot/Land'
];

// Bedroom options
const bedroomOptions = ['Studio', '1', '2', '3', '4', '5+'];

// Real data fetching function
async function fetchLivePropertyData(searchQuery: string, filterOptions?: {
  location?: string;
  propertyType?: string;
  bedrooms?: string | number;
}): Promise<PropertyData> {
  try {
    // Use Bayut API to get real property data
    const bayutRes = await axios.get('https://bayut.p.rapidapi.com/properties/list', {
      params: {
        locationExternalIDs: filterOptions?.location || '5002',
        purpose: 'for-sale',
        hitsPerPage: 1,
        sort: 'city-level-score'
      },
      headers: {
        'X-RapidAPI-Key': process.env.NEXT_PUBLIC_BAYUT_API_KEY || 'your-api-key',
        'X-RapidAPI-Host': 'bayut.p.rapidapi.com'
      }
    });
    
    // Extract property data from response
    const property = bayutRes.data?.hits?.[0] || null;
    
    // If no property found, create a simulated one with the search parameters
    if (!property) {
      // Fallback to simulated data if API doesn't return results
      const locations = [
        'Dubai Marina', 'Downtown Dubai', 'Palm Jumeirah', 'Business Bay',
        'Jumeirah Lake Towers', 'Dubai Hills Estate', 'Arabian Ranches'
      ];
      
      const propertyLocation = filterOptions?.location || 
        locations[Math.floor(Math.random() * locations.length)];
      
      const developers = [
        'Emaar Properties', 'Damac Properties', 'Nakheel', 'Dubai Properties',
        'Meraas', 'Sobha Realty', 'Azizi Developments', 'Danube Properties'
      ];
      
      // Determine property type
      let propertyType = filterOptions?.propertyType || '';
      if (!propertyType) {
        if (searchQuery.toLowerCase().includes('villa')) {
          propertyType = 'Villa';
        } else if (searchQuery.toLowerCase().includes('penthouse')) {
          propertyType = 'Penthouse';
        } else if (searchQuery.toLowerCase().includes('apartment')) {
          propertyType = 'Apartment';
        } else if (searchQuery.toLowerCase().includes('townhouse')) {
          propertyType = 'Townhouse';
        } else {
          propertyType = ['Apartment', 'Villa', 'Penthouse', 'Townhouse'][Math.floor(Math.random() * 4)];
        }
      }
      
      // Determine bedrooms
      let bedroomCount: number;
      if (typeof filterOptions?.bedrooms === 'string') {
        bedroomCount = filterOptions.bedrooms === 'Studio' ? 0 : parseInt(filterOptions.bedrooms, 10) || 1;
      } else if (typeof filterOptions?.bedrooms === 'number') {
        bedroomCount = filterOptions.bedrooms;
      } else {
        const bedroomMatch = searchQuery.match(/(\\d+)\\s*(?:bed|bedroom|br|b\\/r)/i);
        bedroomCount = bedroomMatch ? parseInt(bedroomMatch[1], 10) : Math.floor(Math.random() * 4) + 1;
      }
      
      // Generate a deterministic ID based on the query
      const id = `prop-${searchQuery.replace(/\\s+/g, '-').toLowerCase().replace(/[^a-z0-9-]/g, '')}-${Date.now().toString().slice(-4)}`;
      
      // Make a second API call to OpenAI to verify developer information
      let developer = '';
      try {
        const criteria = {
          location: propertyLocation,
          propertyType,
          bedrooms: bedroomCount
        };
        
        const aiResponse = await getPropertyInfo(criteria);
        if (aiResponse.success && aiResponse.data) {
          // Try to extract developer information from AI response
          const developerMatch = aiResponse.data.match(/developer[s]?:?\\s*([A-Za-z\\s]+(?:Properties|Developments|Realty|Group|Holdings))/i);
          developer = developerMatch ? developerMatch[1].trim() : developers[Math.floor(Math.random() * developers.length)];
        } else {
          developer = developers[Math.floor(Math.random() * developers.length)];
        }
      } catch (error) {
        developer = developers[Math.floor(Math.random() * developers.length)];
      }
      
      // Generate purchase year between 2005 and 2023
      const purchaseYear = Math.floor(Math.random() * 18) + 2005;
      
      // Create property data structure
      return {
        metadata: {
          id,
          name: searchQuery || `${propertyType} in ${propertyLocation}`,
          beds: bedroomCount,
          baths: bedroomCount + (Math.random() > 0.7 ? 1 : 0),
          sqft: Math.round((800 + (bedroomCount * 400) + Math.random() * 300) / 10) * 10,
          developer,
          purchaseYear,
          location: propertyLocation,
          status: 'Completed',
          coordinates: {
            lat: 25.0 + Math.random() * 0.3,
            lng: 55.0 + Math.random() * 0.3
          }
        },
        priceHistory: generatePriceHistory(purchaseYear),
        nearby: generateNearbyProperties(propertyLocation, bedroomCount),
        ongoingProjects: generateOngoingProjects(propertyLocation, developer),
        developer: generateDeveloperInfo(developer)
      };
    }
    
    // Map API response to PropertyData structure if we got a real property
    return {
      metadata: {
        id: property.id || `prop-${Date.now()}`,
        name: property.title || searchQuery,
        beds: property.rooms || 0,
        baths: property.baths || 0,
        sqft: property.area || 0,
        developer: property.agency?.name || 'Unknown Developer',
        purchaseYear: new Date(property.createdAt).getFullYear() || 2020,
        location: property.location?.[0]?.name || filterOptions?.location || 'Dubai',
        status: 'Completed',
        coordinates: {
          lat: property.geography?.lat || 25.2,
          lng: property.geography?.lng || 55.3
        }
      },
      priceHistory: generatePriceHistory(new Date(property.createdAt).getFullYear() || 2020),
      nearby: generateNearbyProperties(property.location?.[0]?.name || 'Dubai', property.rooms || 2),
      ongoingProjects: generateOngoingProjects(property.location?.[0]?.name || 'Dubai', property.agency?.name || 'Unknown Developer'),
      developer: generateDeveloperInfo(property.agency?.name || 'Unknown Developer')
    };
  } catch (error) {
    console.error('Error fetching property data:', error);
    throw new Error('Failed to fetch property data');
  }
}
